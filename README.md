# java_study
자바 스터디를 위한 저장소

# 객체지향언어
재사용성, 유지보수, 중복 코드 제거

클래스 객체를 정의해놓은 것 또는 객체의 설계도 또는 틀
클래스로부터 객체를 만드는 과정을 클래스의 인스턴스화라고 하며, 클래스로부터 만들어진 객체를 클래스의 인스턴스라고 한다.

1. 변수 : 하나의 데이터를 저장할 수 있는 공간
2. 배열 : 같은 종류의 여러 데이터를 하나의 집합으로 저장할 수 있는 공간
3. 구조체 : 서로 관련된 여러 데이터를 종류에 관계없이 하나의 집합으로 저장할 수 있는 공간
4. 클래스 : 데이터와 함수의 결합(구조체+함수)
ex) TV 설계도가 클래스라면, TV는 객체(TV클래스의 인스턴스)이다.

Tv t; //Tv 클래스 타입의 참조변수 선언
Cancel changes
t = new Tv(); //new 연산자를 통해 Tv클래스의 인스터스가 메모리 빈 공간에 생성됨

예제는 classStudy 참고

## 오버로딩과 오버라이딩
  1. 오버로딩 : 기존에 없는 새로운 메서드를 정의하는 것.
      testFunc() {} -> testFunc(int a) {}
  2. 오버라이딩 : 상속받은 메서드의 내용을 변경하는 것.
      이름, 매개변수, 반환타입이 같아야한다. 내용만 변경되는 것.
      parent class{ int testFunc(int a){return a;} } -> child class { int testFunc(int a){ System.out.println(a); return a;} }\
      
예제는 inheritance, overloading 참고
  
## 제어자
#### 접근 제어자
public > protected > (default) > private
클래스나 멤버(변수,메서드)에 접근 제어자를 두어 데이터를 보호. 외부에서 함부로 데이터를 변경하지 못하도록 접근을 제어. data hiding, 캡슐화에 해당
외부에서 접근할 필요가 없는 멤버들을 private으로 지정하여 외부에 노출시키지 않음으로써 복잡성을 줄임
만약 코드가 일부 변경되었을 때, 접근 제어가 public이라면 오류 테스트의 범위가 넓어짐. 하지만 접근제어자가 private이라면 클래스 하나만 살피면 됨.
1. private 같은 클래스 내에서만 접근 가능. 같은 클래스 내에서만 접근이 가능하기 때문에 오버라이딩 될 수 없음.
2. protected 같은 패키지 내. + 자손 클래스에서 접근이 가능하도록 함
3. public 제한이 없다.
4. default는 같은 패키지 내에서만 접근
#### 그 외
1. static
    static 변수는 하나의 변수를 모든 인스턴스가 공유. 클래스가 메모리에 로드될 때 생성되기 때문에 인스턴스 생성 없이 사용 가능.
    static 메서드는 인스턴스 생성 없이 호출이 가능하며, static 메서드 내에서는 인스턴스맴버들을 직접 사용할 수 없음. 인스턴스 생성 없이 호출이 가능하기 때문에 인스턴스 멤버는 사용할 수 없음. 따라서 인스턴스 멤버를 사용하지 않는 메서드에 static을 붙이면, 더 편리하고 속도도 빠름
2. final
    마지막의, 변경될 수 없는.
    final 변수 : 변경할 수 없는 상수
    final 메서드는 : 오버라이딩 할 수 없음
    final class : 확장 불가능. 따라서 다른 클래스의 조상이 될 수 없음.
3. abstract
    미완성의. 메서드의 선언부만 작성하고, 실제 수행내요은 구현하지 않은 추상 메서드 선언에 사용. 
    추상 클래스는 아직 완성되지 않은 메서드가 존재하는 미완성된 설계도이므로, 인스턴스를 생성할 수 없음.
    다른 크래스가 이 클래스를 상속받아서 일부 원하는 메서드만 오버라이딩해서 사용.
    
    
## 추상 클래스와 인터페이스
추상클래스 : 미완성 설계도. 상속을 통해 자손클래스에서 구현하도록 함. 여러 클래스의 공통점을 찾아내서 공통 조상을 만드는 작업. 생명체 추상 클래스{ 걷기 메소드, 나이 변수} - 사람, 동물 등이 자손 클래스가 될 수 있음
인터페이스 : 일종의 추상클래스. 추상클래스보다 추상화 정도가 높음. 추상클래스와 달리 몸통을 갖춘 일반 메서드 또는 멤버변수를 구성원으로 가질 수 없다. 오직 추상 메서드와 상수만을 멤버로 가질 수 있다. ex) interface 인터페이스 { public static final a = 값; public abstract 메서드이름(매개변수목록); }  <- 메서드 몸통 X


추상클래스는 IS - A "~이다". 
  ex) 생명체는 번식한다, 나이가 있다. (공통된 부분)
인터페이스는 HAS - A "~을 할 수 있는".
  ex) 사람은 말을 할 수 있다, 동물은 울 수 있다. 등
예제는 InterfaceTest 참고.

#### 인터페이스의 장점
1. 개발 시간 단축 : 인터페이스를 먼저 작성되면, 메서드 호출 쪽에서는 메서드의 내용과 관계없이 선언부만을 가지고 코드를 작성할 수 있다.
2. 표준화 가능 : 프로젝트에 사용되는 기본 틀을 인터페이스로 제공
3. 서로 관계없는 클래스들에게 관계를 맺어줄 수 있음 : 서로 상속관계도 아니고, 같은 조상클래스를 가지고 있지 않은 아무런 관계가 없는 클래스들에게 하나의 인터페이스를 공통적으로 구현하도록 함으로써 관계를 맺어줄 수 있다.
4. 독립적인 프로그래밍 : 클래스의 선언과 구현을 분리. - 예를 들어, 한 DB회사가 특정 DB를 사용하는데, 필요한 클래스를 사용해서 프로그램을 작성하고 추후 다른 DB를 사용하고자 한다면, DB관련 코드를 모두 변경해야 할 것이다. 하지만 DB 관련 인터페이스를 정의하고, 이를 이용해서 프로그램을 작성하면 DB의 종류가 변경되더라도 프로그램을 변경하지 않도록 할 수 있다.

#### default method
인터페이스를 아무리 잘 생성해도 언젠가는 메서드가 추가될 수 있다.
인터페이스에 메서드가 추가되면 이를 구현한 모든 클래스들이 추가된 메서드를 구현하야 한다.
이럴 때 default method를 사용할 수 있다. default method는 구현해도 되고, 하지 않아도 된다.
일반적인 method 생성 방식에서 앞에 default를 붙이고, 뒤에 몸체{} 를 붙여서 선언한다.
